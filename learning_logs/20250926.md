# CORS Filter 추가하기
- CORS(Cross-Origin Resources Sharing) : 클라이언트와 서버가 교차 출처 재요청을 허용할 지 거부할지를 결정하게 하는 특정 헤더를 가짐.
- CORS filter는 다른 출처에서 요청을 보내는 프론트 엔드와의 통신에서 필요
- 프론트엔드 상에서 특정 요청이 백엔드로 넘어가게 되는 과정에서 CORS 필터가 요청을 중간에 확인하여, 교차 출처로 식별되면 요청에 적절한 헤더를 추가하여 서로 통신을 주고 받을 수 있도록 허용해줌.
- CorsConfigurationSource 인터페이스를 사용
- 현재까지의 예제에서는 모든 출처의 HTTP 메서드와 헤더를 허용하는 상태

1. SecurityConfig 클래스를 수정합니다.
```java
package com.example.cardatabase;

import com.example.cardatabase.service.UserDetailsServiceImpl;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final UserDetailsServiceImpl userDetailsService;
    private final AuthenticationFilter authenticationFilter;
    private final AuthEntryPoint exceptionHandler;

    public SecurityConfig(UserDetailsServiceImpl userDetailsService, AuthenticationFilter authenticationFilter, AuthEntryPoint exceptionHandler) {
        this.userDetailsService = userDetailsService;
        this.authenticationFilter = authenticationFilter;
        this.exceptionHandler = exceptionHandler;
    }

    public void configGlobal (AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder());
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable())
                .sessionManagement(sessionManagement -> sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authorizeHttpRequests -> authorizeHttpRequests.requestMatchers(HttpMethod.POST, "/login").permitAll().anyRequest().authenticated())
                .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exceptionHandling -> exceptionHandling.authenticationEntryPoint(exceptionHandler));
        return http.build();
    }
}
```

cors 관련 추가
```java
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowedOrigins(Arrays.asList("*"));
        config.setAllowedMethods(Arrays.asList("*"));
        config.setAllowedHeaders(Arrays.asList("*"));
        
        config.setAllowCredentials(false);
        config.applyPermitDefaultValues();
        
        source.registerCorsConfiguration("/**", config);
        return source;
    }
```
특정 Origin만을 명시적으로 정의하려면
`config.setAllowOrigins(Arrays.asList("http://localhost:5173","http://localhost:3000"))`
과 같이 사용할 수 있음. 어차피 5173일거니까 헷갈리면 ctrl + 5173 검색

2. SecurityConfig를 수정했으니 filterChain 관련 method도 수정해야 함
```java
import static org.springframework.security.config.Customizer.withDefaults;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable())
                .cors(withDefaults())       // 여기 추가했음. static 메서드 추가하는 import문도 추가됨
                // 특정 port만 열릴 수 있도록 설정하는 구문
                .sessionManagement(sessionManagement -> sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authorizeHttpRequests -> authorizeHttpRequests.requestMatchers(HttpMethod.POST, "/login").permitAll().anyRequest().authenticated())
                .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exceptionHandling -> exceptionHandling.authenticationEntryPoint(exceptionHandler));
        return http.build();
    }
```

# Role-Based Protection
- Spring Security는 역할을 이용하여 세분화된 역할 기반 보안을 정의할 수 있으며, 사용자는 하나 또는 여러 역할에 할당되어질 수 있다. 역할은 흔히 ADMIN / MANAGER / USER 와 같은 계층 구조를 가지게 되는데 USER가 할 수 있는 모든 일은 MANAGER가 다 할 수 있으면서 MANAGER는 USER보다 더 많은 접근 권한을 가지고, ADMIN은 MANGER가 할 수 있는걸 또 다 할 수 있으면서 자기만 할 수 있는 다른 접근 권한을 갖는 등으로 생각하시면 되겠습니다.

SecurityConfig 클래스의 요청 수준에서 역할 기반 접근 제어를 정의할 수 있음
이하의 예제 코드에서는 접근을 위한 특정 역할이 필요한 엔드포인트를 정의함.
ex - `/admin/**` 엔드포인트에 접근하려면 ADMIN 역할이 필요하고, `/user/**` 엔드포인트에 접근하려면 USER 역할이 필요함. 
사용자가 지정된 역할을 가지고 있으면 true를 반환하는 Spring security hasRole() 메서드를 이용.

Role-Based Protection 적용 filterChain 예시(예제 프로젝트에는 도입 X)
.authorizeHttpRequests 부분 수정함
```java
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable())
                .cors(withDefaults())
                .sessionManagement(sessionManagement -> sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authorizeHttpRequests -> authorizeHttpRequests.requestMatchers("/admin/**").hasRole("ADMIN").requestMatchers("/user/**").hasRole("USER").anyRequest().authenticated())
                .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exceptionHandling -> exceptionHandling.authenticationEntryPoint(exceptionHandler));
        return http.build();
    }
```
Spring Security는 Method 수준의 보안을 적용하는데 이용되는 `@PreAuthorize, @PostAuthorized, @PreFilter, @PostFilter, @Secured` 애너테이션들이 있음. 메서드 수준 보안은 default로 spring-boot-starter-security에서 이용하도록 설정되어 있지 않음.
스프링 구성 클래스(최상위-저희 기준으로 CarDatabaseApplication)에서 `@EnableMethodSecurity`애너테이션을 이용하여 활성화해야 하는데... 예시로 남겨두지는 않겠습니다.

# BackEnd Tests



















