# TodoList Project
1. 프로젝트 생성
2. 필요 의존성 추가 후 Generate
  - 다운 받아서 압축 풀고 springboot 폴더로 옮김
  - intellij를 실행 시켜서 프로젝트가 올바로 생성 됐는지 체크
  - 현재 상황에서 대부분의 의존성을 제대로 체크했더라고 실행되지 않음
  - 데이터베이스 자체가 없었기 때문
  - 그래서 heidiSQL 킨 다음에 tododb 생성해주고 springboot 애플리케이션을 실행했더니 spring seurity가 적용된 상태로 실행이 됨

## domain - Entity 
- User(사용자 Entity) / Todo (할일 목록 Entity)
```java
// user Entity
@Entity
@Table(name = "users")
@Data
@NoArgsConstructor
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(nullable = false, updatable = false)
    private Long id;

    @Column(nullable = false, unique = true)
    private String username;

    @Column(nullable = false)
    private String password;

    @Column(nullable = false)
    private String role;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Todo> todos = new ArrayList<>();

    public User(String username, String password, String role) {
        this.username = username;
        this.password = password;
        this.role = role;
    }
}

// Todo entity
@Entity
@Getter
@Setter
@NoArgsConstructor
public class Todo {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    @Column(nullable = false)
    private String content;

    private boolean isCompleted = false;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    @JsonIgnore
    private User user;

    public Todo(String content, User user) {
        this.content = content;
        this.user = user;
    }
}
```
- @Table(name = "users") : User가 예약어라서 나중에 문제가 생길 수 있으므로 데이터베이스 상에서의 테이블 명을 따로 지정
- @GeneratedValue(strategy = GenerationType.AUTO) : DB 상에서의 AutoIncrement
- @Column 속성 (제약 조건)
  - nullable = false : null 방지
  - updatable = false : 함부로 값을 바꿀 수 없음 (id 작성 시)
  - unique = true : 겹치면 안되기 때문에 unique 설정

- @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
  - id 하나 당 다수의 투두를 가질 수 있음
  - cascade = CascadeType.ALL : User가 저장/삭제될 때 연관된 todo도 같이 처리 (예: User 삭제 시 todo도 삭제)
  - orphanRemoval = true	todos : 리스트에서 todo 객체가 제거되면 DB에서도 삭제됨

- @ManyToOne(fetch = FetchType.LAZY) : 지연 로딩(Lazy Loading) 설정
  - todo 엔티티를 조회할 때 즉시 User까지 함께 불러오지 않고, 필요할 때(User를 실제로 접근할 때) DB에서 따로 조회

- @JoinColumn(name = "user_id") : 실제 DB에서 user 필드를 외래키(FK)로 매핑할 컬럼 이름을 지정
- @JsonIgnore : @RestController나 ResponseEntity로 JSON 응답을 보낼 때, todo 안의 User 객체를 JSON으로 변환하지 않도록 막는 역할. 무한 반복을 방지

- DTO
  - 데이터를 잠시 담아두는 역할 
  - ex) todo에 User 객체를 담아야하는데 프론트앤드 상에서는 content만 담아오기 때문에 content와 User를 조합해서 생성자를 생성해야 함. 그러기 위해서 content를 dto에 담아두고 service에서 user와 조합함.

- jwt 생성 후 security 설정까지 했을 때 현재 로그인 한 유저를 가져오는 코드 작성 예시
  - SecurityContextHolder 사용
```java
    private User getCurrentUser() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String username = authentication.getName();
        return userRepository.findByUsername(username).orElseThrow(() -> new EntityNotFoundException("User를 찾을 수 없습니다."));
    }
```